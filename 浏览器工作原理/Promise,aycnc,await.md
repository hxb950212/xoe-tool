####################Promise 解决回调地狱方式
第一是消灭嵌套调用；
首先，Promise 实现了回调函数的延时绑定
其次，需要将回调函数 onResolve 的返回值穿透到最外层

第二是合并多个任务的错误处理;
是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。

#Promise 中为什么要引入微任务？
由于 promise 采用.then 延时绑定回调机制，而 new Promise 时又需要直接执行 promise 中的方法，即发生了先执行方法后添加回调的过程，此时需等待 then 方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前 js 调用栈中执行结束后的任务队列中，由于宏任务容易堵塞，则采用了微任务

#Promise 中是如何实现回调函数返回值穿透的？
首先 Promise 的执行结果保存在 promise 的 value 变量中，然后是.then 方法返回值为使用 resolved 或 rejected 回调方法新建的一个 promise 对象，即例如成功则返回 new Promise（resolved），将前一个 promise 的 value 值赋给新建的 promise

#Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？
promise 内部有 resolved 和 rejected 变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断 rejected 参数是否为函数，若是函数，错误时使用 rejected 处理错误；若不是，则错误时直接 throw 错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听 unhandledrejection 事件捕获未处理的 promise 错误

#####################协程
要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。
